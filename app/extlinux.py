import io
import subprocess
from boot_control import BootControlMixinInterface


def _findfs(self, key: str, value: str) -> str:
    """
    findfs finds a partition by conditions
    Usage:
        findfs [options] {LABEL,UUID,PARTUUID,PARTLABEL}=<value>
    """
    try:
        return subprocess.check_output(f"findfs {key}={value}").decode().strip()
    except subprocess.CalledProcessError:
        return ""

class blkidWrapper:

    @classmethod
    def _blkid(cls, args: str) -> str:
        try:
            return subprocess.check_output(f"blkid {args}").decode().strip()
        except subprocess.CalledProcessError:
            return ""

    @classmethod
    def get_partuuid_by_dev(cls, dev: str) -> str:
        args = f"{dev} -s PARTUUID"
        res = cls._blkid(args)
        return res.split(':')[-1].strip(' "')

class nvbootctrlWrapper:
    """
    slot num: 0->A, 1->B
    slot suffix: "", "_b"
    rootfs default label prefix: APP
    """
    _prefix = "APP"
    _active_standby_flip = { "0": "1", "1": "0"}

    @classmethod
    def _nvbootctrl(cls, arg) -> str: 
        # NOTE: target is always set to rootfs
        _cmd = "nvbootctrl -t rootfs "
        try:
            res = subprocess.check_output(_cmd + arg).decode().strip()
            return res
        # TODO: logger here
        except subprocess.CalledProcessError as e:
            raise e

    @classmethod
    def get_current_slot(cls) -> str:
        return cls._nvbootctrl("get-current-slot")

    @classmethod
    def get_current_slot_dev(cls) -> str:
        slot = cls.get_current_slot()
        suffix = cls.get_suffix(slot)
        return _findfs("PARTLABEL", suffix)

    @classmethod
    def get_current_slot_partuuid(cls) -> str:
        dev = cls.get_current_slot_dev()
        return blkidWrapper.get_partuuid_by_dev(dev)
    
    @classmethod
    def get_stanby_slot(cls) -> str:
        return cls._active_standby_flip(cls.get_current_slot)

    @classmethod
    def get_standby_slot_dev(cls) -> str:
        slot = cls.get_stanby_slot()
        suffix = cls.get_suffix(slot)
        return _findfs("PARTLABEL", suffix)

    @classmethod
    def get_standby_slot_partuuid(cls) -> str:
        dev = cls.get_standby_slot_dev()
        return blkidWrapper.get_partuuid_by_dev(dev)

    @classmethod
    def get_suffix(cls, slot: str) -> str:
        return cls._nvbootctrl(f"get-suffix {slot}")

    @classmethod
    def mark_boot_successful(cls, slot: str):
        cls._nvbootctrl(f"mark-boot-successful {slot}")

    @classmethod
    def set_active_boot_slot(cls, slot: str):
        cls._nvbootctrl(f"set-active-boot-slot {slot}")

    @classmethod
    def set_slot_as_unbootable(cls, slot: str):
        cls._nvbootctrl(f"set-slot-as-unbootable {slot}")

    @classmethod
    def is_slot_bootable(cls, slot: str) -> bool:
        try:
            cls._nvbootctrl(f"is-slot-bootable {slot}")
            return True
        except subprocess.CalledProcessError:
            return False
    
    @classmethod
    def is_slot_marked_successful(cls, slot: str) -> bool:
        try:
            cls._nvbootctrl(f"is-slot-marked-successful {slot}")
            return True
        except subprocess.CalledProcessError:
            return False

class ExtlinuxCfgFile:
    _heading = {
        "TIMEOUT": 30,
        "DEFAULT": "primary",
        "MENU TITLE": "L4T boot options"
    }

    _entry = dict()

    def load_entry(
        self,
        label: str,
        menu_lable: str,
        fdt: str,
        linux: str="/boot/Image",
        initrd: str="/boot/initrd",
        append: str="",
    ):
        entry = dict()
        entry["MENU LABEL"] = menu_lable
        entry["LINUX"] = linux
        entry["INITRD"] = initrd
        entry["FDT"] = fdt
        entry["APPEND"] = '${cbootargs} quiet ' + f"{append}"
        self._entry[label] = entry

    def dump_cfg(self) -> io.StringIO:
        """
        dump_cfg dumps the extlinux config file to a StringIO object
        """
        buff = io.StringIO()
        _write = lambda s="": buff.write(s + '\n')
        _comment = lambda s="": buff.write('# ' + s + '\n')

        _comment("Auto generated by ota-client, DO NOT EDIT!")
        # generate heading
        for k, v in self._heading.items():
            _write(f"{k} {v}")

        # populate entry
        for t, e in self._entry.items():
            _write(f"LABEL {t}")
            for mt, mop in e.items():
                _write(f"\t{mt} {mop}")

        return buff

class CBootControlMixin(BootControlMixinInterface):
    pass


class CBootControl:
    pass


class ExtlinuxControl:
    """
    NOTE: only for tegraid:0x19, jetson xavier platform
    """
    _cmdline = "root=PARTUUID=${_tmp_uuid} rw rootwait rootfstype=ext4 "
    _rootfs = None
    _tty = "console=ttyTCU0,115200n8 console=tty0"
    _extra = "fbcon=map:0 net.ifnames=0"

    _slots = dict() # slot_num: partUUID
    _active_slot = None
    _standby_slot = None

    _extlinux: ExtlinuxCfgFile = None

    def __init__(self):
        pass